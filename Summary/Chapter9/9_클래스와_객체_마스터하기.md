## 목차

---

# 소개

- 이번 장에서는 클래스와 객체를 최대한 활용하는 방법에 대해서 알아보자.

## 배울 내용
- 객에체 동적 메모리 할당하는 법
- 복제 후 맞바꾸기 패턴
- 우측값과 우측값 레퍼런스
- 이동 의미론을 적용하면 성능을 높일 수 있는 이유
- 영의 규칙
- 데이터 멤버의 종류
- 메서드의 종류
- 메서드 오버로딩의 세부사항
- 디폴트 인수 활용법
- 중첩 클래스 사용법
- friend로 클래스 연결
- 연산자 오버로딩
- 인터페이스와 구현 클래스 구분법

# 9.1 friend
- friend로 지정한 대상은 이 클래스의 protected나 private 데이터 멤버와 메서드에 접근할 수 있음.

```cpp
class Foo {

    friend class Bar;
    // ...
};
```
- Foo는 Bar와 친구이다.
- Bar는 Foo의 protected와 private 데이터 멤버에 접근 가능
- 특정 메서드만 friend로 만들 수도 있다.
- 하지만 이 기능을 너무 많이 사용하면 클래스의 내부가 외부 클래스나 함수에 드러나서 캡슐화의 원칙이 깨진다.
- 꼭 필요할 때만 사용하자.

# 9.2 객체에 동적 메모리 할당하기

- 객체에 메모리를 동적으로 할당할 때는 메모리 해제, 객체 복제 처리, 객체 대입 연산 처리 등을 비롯한 까다로운 문제 발생

## 9.2.1 Spreadsheet 클래스
- Spreadsheet 클래스를 단계별로 업그레이드 하면서 소개
- Spreadsheet를 SpreadsheetCell 타입의 2차원 배열로 만든다.
- 아래는 Spreadsheet의 첫 번째 버전

```cpp
#include <cstddef>
#include "SpreadsheetCell.h"

class Spreadsheet
{
    public:
        Spreadsheet(size_t width, size_t height);
        void setCellAt(size_t x, size_ y, const SpreadsheetCell& cell);
        SpreadsheetCell& getCellAt(size_t x, size_t y);
    private:
        bool inRange(size_t value, size_t upper) const;
        size_t mWidth = 0;
        size_t mHeight = 0;
        SpreadsheetCell** mCells = nullptr;
};
```

- 다음은 2차원 배열을 동적으로 할당하는 코드이다. 
- 이는 자바와 달리 간단하지 않음에 주의

```cpp
Spreadsheet::Spreadsheet(size_t width, size_t height)
    : mWidth(width), mHeight(height)
{
    mCells = new SpreadsheetCell*[mWidth];
    for (size_t i = 0; i < mWidth; i++) {
        mCells[i] = new SpreadsheetCell[mHeight];
    }
}
```

- 셀 하나를 읽고 쓰는 메서드 구현

```cpp
void Spreadsheet::setCellAt(int x, int y, const SpreadsheetCell& cell) {
    if (!inRange(x, mWidth) || !inRange(y, mHeight)) {
        throw std::out_of_range("");
    }
    mCells[x][y] = cell;
}

SpreadsheetCell& Spreadsheet::getCellAt(int x, int y) {
    iif (!inRange(x, mWidth) || !inRange(y, mHeight)) {
        throw std::out_of_range("");
    }
    return mCells[x][y];
}
```

- inRange 라는 헬퍼 메서드를 통해 좌표가 유효한지 확인함.
- 하지만 위의 두 함수는 중복되어지는 코드가 있다.
- 아래와 같은 메서드를 이 클래스에 따로 정의

```cpp
void verifyCoordinate(size_t x, size_ y) const;
```

- 정상 범위가 아니라면 예외를 던지도록 구현!

```cpp
void Spreadsheetcell::verifyCoordinate(size_t x, size_t y) const {
    if (x >= mWidth || y >= mHeight) {
        throw std::out_of_range("");
    }
}

// 수정 후 getCellAt, setCellAt 메서드
void Spreadsheet::setCellAt(size_t x, size_t y, const SpreadsheetCell& cell) {
    verifyCoordinate(x, y);
    mCells[x][y] = cell;
}

void Spreadsheet::getCellAt(size_t x, size_t y, const SpreadsheetCell& cell) {
    verifyCoordinate(x, y);
    return mCells[x][y];
}
```

## 9.2.2 소멸자로 메모리 해제하기
- 객체의 소멸자에서 해제하는 것이 바람직

```cpp
// Spreadsheet에 소멸자 선언
class Spreadsheet {
    public:
        Spreadsheet(size_t width, size_t height);
        ~Spreadsheet();
        // 생략
};
```

- 아무런 익셉션이 발생하지 않으므로 소멸자는 기본적으로 noexcept 적용

```cpp
// Spreadsheet 클래스의 소멸자 구현
Spreadsheet::~Spreadsheet() {
    for (size_t i = 0; i < mWidth; i++) {
        delete [] mCells[i];
    }
    delete [] mCells;
    mCells = nullptr;
}
```

## 9.2.3 복제와 대입 처리하기

- 8장에서 복제 생성자 or 대입 연산자를 작성하지 않으면 컴파일러가 대신 생성해준다고 함.
- 이렇게 생성된 메서드는 복제 생성자 or 대입 연산자를 재귀적으로 호출함.
- 여기서 기본 타입에 대새허는 **비트 단위 복제, 얕은 복제** 또는 대입이 적용

### 댕글링 포인터

```cpp
#include "Spreadsheet.h"

void printSpreadsheet(Spreadsheet s){
    // 생략
}

int main() {
    Spreadsheet s1(4, 3);
    printSpreadsheet(s1);
    return 0;
}
```
- 위의 예에서 Spreadsheet 객체 s1을 전달하면
- 이 함수의 s를 초기화 하는 과정에서 s1을 복제
- 이렇게 전달한 Spreadsheet는 mCells 라는 포인터변수 하나만 가지고 있음
- 따라서 s와 s1이 같은 데이터를 가리키는 포인터가 발생!
- 이 상태에서 s가 변경되면 s1에도 그 결과가 반영
- 더 심각한 문제는 s의 소멸자가 호출되어지면서 mCells가 가리키던 메모리까지 해제!
- 이를 **댕글링 포인터**라고 부름.


### 메모리 누수

- 대입 연산을 수행할 때는 이보다 더 심각한 문제 발생

```cpp
Spreadsheet s1(2,2), s2(4,3);
s1 = s2;
```

- s1과 s2에 있는 mCells 포인터가 가리키는 방향이 똑같을 뿐 아니라,
- s1에서 mCells가 가리키던 메모리는 미아가 됨!
- 이를 **메모리 누수** 라고 한다.
- 따라서... 컴파일러가 자동으로 생성하는 복제 생성자 or 대입 연산자를 그대로 사용하지말 것!

### 1. Spreadsheet 복제 생성자
```cpp
// 복제 생성자 생성
class Spreadsheet
{
    public:
        Spreadsheet(const Spreadsheet& src);
        // 생략
};

// 복제 생성자 정의
Spreadsheet::Spreadsheet(const Spreadsheet& src)
    : Spreadsheet(src.mWidth, src.mHeight)
{
    for (size_t i = 0; i < mWidth; i++) {
        for (size_t j = 0; j < mHeight; j++) {
            mCells[i][j] = src.mCells[i][j];
        }
    }
}
```
- 이렇게 하면 동적으로 할당된 2차원 배열인 mCells를 깊은 복제로 처리가 가능
- mCells를 삭제하는 작업 필요 없음.

### 2. Spreadsheet 대입 연산자
```cpp
// 대입 연산자 선언
class Spreadsheet
{
    public:
        Spreadsheet& operator=(const Spreadsheet& rhs);
        // 생략
};

// 대입 연산자 단순 구현
Spreadsheet& Spreadsheet::operator=(const Spreadsheet& rhs)
{
    // 자기 자신인지 확인
    if (this == &rhs) {
        return *this;
    }

    // 기존 메모리 해제
    for (size_t i = 0; i < mWidth; i++) {
        delete [] mCells[i];
    }
    delete[] mCells;
    mCells = nullptr;
    
    // 메모리를 새로 할당.
    mWidth = rhs.mWidth;
    mHeight = rhs.mHeight;

    mCells = new Spreadsheetcell*[mWidth];
    for (size_t i = 0; i < mWidth; i ++) {
        mCells[i] = new SpreadsheetCell[mHeight]; // 익셉션 발생!
    }

    // 데이터 복제
    for (size_t i = 0; i < mWidth; i++) {
        for (size_t j = 0; j < mHeight; j++) {
            mCells[i][j] = rhs.mCells[i][j];
        }
    }
    return *this;
}
```
- 만약 위의 코드에서 익셉션이 발생했다고 하면 문제가 생기게 된다.
- 데이터 멤버 mWidth, mHeight는 일정크기를 갖고 있지만 실제로는 mCells 데이터 멤버에 필요한 만큼의 메모리를 갖고있지 않는다.
- 문제가 생기지 않도록 **복제 후 맞바꾸기** 패턴을 적용하여 해결한다.

- Spreadsheet 클래스에 대입 연산자와 swap() 함수를 추가함.
```cpp
class Spreadsheet
{
    public:
        Spreadsheet& operator=(const Spreadsheet& rhs);

        // 비 멤버 함수로, 예외가 일어나지 않도록 noexcept
        friend void swap(Spreadsheet& first, Spreadsheet& second) noexcept; 
}

// swap 구현
void swap(Spreadsheet& first, Spreadsheet& second) noexcept
{
    using std::swap;

    swap(first.mWidth, second.mWidth);
    swap(first.mHeight, second.mHeight);
    swap(first.mCells, second.mCells);
}

// swap을 사용한 대입 연산자 구현
Spreadsheet& Spreadsheet::operator=(const Spreadsheet& rhs)
{
    // 자기 자신인지 확인
    if (this == &rhs) {
        return *this;
    }

    Spreadsheet temp(rhs); // 임시 인스턴스에서 처리
    swap(*this, temp); // 익셉션 발생하지 않는 연산으로 작업 처리
    return *this;
}
```
- 익셉션에 대한 안정성 높일 수 있음.

> 정리하면
- 1. 임시 복제본을 만든다.
- 2. swap() 함수를 이용하여 현 객체를 임시 복제본으로 교체
- 3. 임시 객체 제거. 원본 객체가 남음

### 3. 대입과 값 전달 방식 금지
- 대입이나 값 전달 방식을 금지하기 위해 아래와 같이 정의

```cpp
class Spreadsheet
{
    public:
        Spreadsheet(size_t width, size_t height);
        Spreadsheet(const Spreadsheet& src) = delete;
        ~Spreadsheet();
        Spreadsheet& operator=(const Spreadsheet&  rhs) = delete;
    // 생략
};
```
- 위와 같이 작성한 뒤에, Spreadsheet 객체를 복사 or 어떤 값 대입시 에러 메시지를 출력함

## 9.2.4 이동 의미론으로 이동 처리하기


### 1. 우측값 레퍼런스


### 2. 이동 의미론 구현 방법


> 객체 데이터 멤버 이동하기

> swap() 함수로 구현한 이동 생성자와 이동 대입 연산자

### 3. Spreadsheet의 이동 연산자 테스트

```cpp
Spreadsheet createObject() {
    return Spreadsheet(3, 2);
}

int main()
{
    vector<Spreadsheet> vec;
    for (int i = 0; i < 2; ++i) {
        cout << "Iteration " << i << endl;
        vec.push_back(Spreadsheet(100, 100));
        cout << endl;
    }

    Spreadsheet s(2, 3);
    s = createObject();

    Spreadsheet s2(5, 6);
    s2= s;
    return 0;
}

// 실행 결과
// Iteration 0
// Normal constructor 1) 
// Move constructor   2)
// Iteration 1
// Normal constructor 3)
// Move constructor 4) 
// Move constructor 5) 
// Normal constructor 6) 
// Normal constructor 7) 
// Move assignment operator 8)
// Normal constructor 9)
// Copy assignment operator 10)
// Normal constructor 11) 
// Copy constructor 12) 

```

### 4. 이동 의미론으로 swap 함수 구현


## 9.2.5 영의 규칙


# 9.3 메서드의 종류


## 9.3.1 static 메서드


## 9.3.2 const 메서드


### 1. mutable 데이터 멤버


## 9.3.3 메서드 오버로딩


### 1. const 기반 오버로딩


### 2. 명시적으로 오버로딩 제거하기


## 9.3.4 인라인 메서드


## 9.3.5 디폴트 인수


# 9.4 데이터 멤버의 종류

## 9.4.1 static 데이터 멤버

### 1. 인라인 변수

### 2. 클래스 메서드에서 static 데이터 멤버 접근하기

### 3. 메서드 밖에서 static 데이터 멤버 접근하기

## 9.4.2 const static 데이터 멤버

## 9.4.3 레퍼런스 데이터 멤버

## 9.4.4 const 레퍼런스 데이터 멤버

# 9.5 중첩 클래스

# 9.6 클래스에 열거 타입 정의하기

# 9.7 연산자 오버로딩

## 9.7.1 예제: SpreadsheetCell에 대한 덧셈 구현

### 1. add 메서드

### 2. operator+ 오버로딩으로 구현

> 묵시적 변환

### 3. operator+ 전역 함수로 구현

## 9.7.2 산술 연산자 오버로딩

### 1. 축약형 산술 연산자의 오버로딩

## 9.7.3 비교 연산자 오버로딩

## 9.7.4 연산자 오버로딩을 지원하는 타입 정의하기

# 9.8 안정적인 인터페이스 만들기

## 9.8.1 인터페이스 클래스와 구현 클래스

# 9.9 요약


