## 목차

- [소개](#소개)
  - [배울 내용](#배울-내용)
- [8.1 스프레드시트 예제](#81-스프레드시트-예제)
- [8.2 클래스 작성 방법](#82-클래스-작성-방법)
  - [8.2.1 클래스 정의](#821-클래스-정의)
    - [1. 클래스 멤버](#1-클래스-멤버)
    - [2. 접근 제어](#2-접근-제어)
    - [3. 선언 순서](#3-선언-순서)
    - [4. 클래스 내부의 멤버 이니셜라이저](#4-클래스-내부의-멤버-이니셜라이저)
  - [8.2.2 메서드 정의 방법](#822-메서드-정의-방법)
    - [1. 데이터 멤버 접근 방법](#1-데이터-멤버-접근-방법)
    - [2. 다른 메서드 호출하기](#2-다른-메서드-호출하기)
    - [3. this 포인터](#3-this-포인터)
  - [8.2.3 객체 사용법](#823-객체-사용법)
    - [1. 스택에 생성한 객체](#1-스택에-생성한-객체)
    - [2. 힙에 생성한 객체](#2-힙에-생성한-객체)
- [8.3 객체의 라이프 사이클](#83-객체의-라이프-사이클)
  - [8.3.1 객체 생성](#831-객체-생성)
    - [1. 생성자 작성 방법](#1-생성자-작성-방법)
    - [2. 생성자 사용법](#2-생성자-사용법)
      - [스택 객체 생성자](#스택-객체-생성자)
      - [힙 객체 생성자](#힙-객체-생성자)
    - [3. 생성자 여러개 제공하기](#3-생성자-여러개-제공하기)
    - [4. 디폴트 생성자](#4-디폴트-생성자)
    - [5. 생성자 이니셜라이저](#5-생성자-이니셜라이저)
    - [6. 복제 생성자](#6-복제-생성자)
    - [7. 이니셜라이저 리스트 생성자](#7-이니셜라이저-리스트-생성자)
    - [8. 위임 생성자](#8-위임-생성자)
    - [9. 컴파일러가 생성하는 생성자에 대한 정리](#9-컴파일러가-생성하는-생성자에-대한-정리)
  - [8.3.2 객체 소멸](#832-객체-소멸)
  - [8.3.3 객체에 대입하기](#833-객체에-대입하기)
    - [1. 대입 연산자 선언 방법](#1-대입-연산자-선언-방법)
    - [2. 대입 연산자 정의 방법](#2-대입-연산자-정의-방법)
    - [3. 명시적으로 디폴트로 만들거나 삭제한 대입 연산자](#3-명시적으로-디폴트로-만들거나-삭제한-대입-연산자)
  - [8.3.4 컴파일러가 만들어주는 복제 생성자와 복제 대입 연산자](#834-컴파일러가-만들어주는-복제-생성자와-복제-대입-연산자)
  - [8.3.5 복제와 대입 구분하기](#835-복제와-대입-구분하기)
    - [1. 리턴값이 객체인 경우](#1-리턴값이-객체인-경우)
    - [2. 복제 생성자와 객체 멤버](#2-복제-생성자와-객체-멤버)
- [8.4 요약](#84-요약)
---

# 소개
- 이번 장에서는 클래스의 정의, 메서드 정의, 스택과 힙에서 객체를 생성해서 사용하는 방법, 생성자 작성법, 디폴트 생성자, 컴파일러가 생성하는 생성자, 생성자 이니셜라이저, 복제 생성자, 이니셜라이저 리스트 생성자, 소멸자, 대입 연산자 등 클래스와 객체에 관련된 핵심 개념을 알아보자.


## 배울 내용
- 나만의 클래스 작성법
- 메서드와 데이터 멤버에 대한 접근 권한 지정법
- 스택이나 힙에 객체를 생성하는 방법
- 객체의 라이프 사이클
- 객체가 생성될 때 실행할 코드 작성법
- 객체를 복사 또는 대입하는 코드 작성법

# 8.1 스프레드시트 예제
- 간단한 스프레드시트 예제로 여러 개념을 설명할 예정
- SpreadsheetCell이라는 기본 클래스 중심으로 소개


# 8.2 클래스 작성 방법
- 객체에 적용할 동작(메서드)과 객체마다 가질 속성(데이터 맴버) 지정
- 클래스를 정의하는 단계와 메서드를 정의하는 단계로 구성


## 8.2.1 클래스 정의
- SpreadsheetCell 클래스의 첫 버전

```cpp
class SpreadsheetCell {
  public:
    // SpreadsheetCell 클래스에서 지원하는 메서드 선언
    void setValue(double inValue);
    double getValue() const;

  private:
    // 클래스의 데이터 멤버 선언
    double mValue;
};
```
- 클래스 정의는 **문장** 이므로 끝날 때, 세미콜론(;)을 빼먹지 말자!
- 클래스 정의를 작성한 파일은 보통 클래스 이름.h 로 짓는다.


### 1. 클래스 멤버
- 클래스는 여러 멤버를 갖는다. 멤버는 **멤버 함수와 멤버 변수(데이터 멤버)** 로 구성
- 멤버 함수 : 메서드 생성자 소멸자
- 멤버 변수(=데이터 멤버) : 열거형, 타입 앨리어스, 중첩 클래스 등..


### 2. 접근 제어
- 각 클래스의 멤버들은 세 가지 **접근 제한자**를 갖는다.
- 클래스에 접근 제한자를 지정하지 않는다면 **private**가 적용

```cpp
class SpreadsheetCell {
  void setValuedouble inValue); // private
  public:
    double getValue() const;
  private:
    double mValue;
};
```
- struct도 마찬가지로 class처럼 메서드를 가질 수 있음.
- 하지만 메서드가 없거나 개수가 적다면(x, y좌표계) class보다 struct 구조를 사용

```cpp
// struct ver
struct SpreadsheetCell {

    void setValue(double inValue);
    double getValue() const;

  private:
    double mValue;
};
```

### 3. 선언 순서
- 선언 순서는 따로 지정한게 없다. 편한대로 하자.
- 가독성을 위해서 public, protected, private로 묶어서 선언하도록 하자!


### 4. 클래스 내부의 멤버 이니셜라이저
- 클래스를 정의할 때는 멤버 변수를 선언하는 동시에 초기화가 가능

```cpp
class SpreadsheetCell{
  // 클래스 정의의 나머지 부분 생략
  private:
    double mValue = 0; // 기본값 0으로 초기화
};
```

## 8.2.2 메서드 정의 방법
- 함수를 만들 때는 프로토타입 뿐만 아니라 함수를 구현하는 정의 코드를 함께 작성하듯이
- 메서드도 프로토타입 뿐만 아니라 메서드를 구현하는 정의 코드도 반드시 작성!
- 메서드 정의 코드보다 클래스 정의 코드가 먼저 나와야 함!

```cpp
#include "SpreadsheetCell.h"

// 메서드 이름 앞에 클래스 이름과 콜론 두 개가 붙은 것을 잘 보자
// :: 는 스코프 지정 연산자 라고 함. 즉, setValue, getValue는 SpreadsheetCell 클래스에 속함
void SpreadsheetCell::setValue(double inValue) {
  mValue = inValue;
}

double SpreadsheetCell::getValue() const {
  return mValue;
}
```

### 1. 데이터 멤버 접근 방법
- setValue() or getValue()는 클래스에 정의된 데이터 멤버 중 현재 객체에 속한 멤버에 대해 접근
- setValue() 메서드를 호출 -> mValue 변수 값을 변경함


### 2. 다른 메서드 호출하기
- SpreadsheetCell 클래스에 텍스트 데이터를 지원하도록 수정한 첫 번째 버전

```cpp
#include <string>
#include <string_view>

class SpreadsheetCell{
  public:
    void setValue(double inValue);
    double getValue() const;

    void setString(std::string_view inString);
    std::string getString() const;
  private:
    std::string doubleToString(double inValue) const;
    double stringToDouble(std::string_view inString) const;
    double mValue;
};
```

- 다음 예제는 위의 네 메서드의 구현이다.

```cpp
#include "SpreadsheetCell.h"
using namespace std;

void SpreadsheetCell::setValue(double inValue){
  mValue = inValue;
}

double SpreadsheetCell::getValue() const{
  return mValue;
}

void SpreadsheetCell::setString(string_view inString){
  mValue = stringToDouble(inString);
}

string SpreadsheetCell::getString() const{
  return doubleToString(mValue);
}

string SpreadsheetCell::doubleToString(double inValue) const {
  return to_string(inValue);
}

double SpreadsheetCell::stringtoDouble(string_view inString) const {
  return strtod(inString.data(), nullptr);
}
```


### 3. this 포인터
- 일반 메서드를 호출하면 항상 메서드가 속한 객체의 포인터인 this가 숨겨진 매개변수 형태로 전달
- this 포인터로 해당 객체의 데이터 멤버나 메서드에 접근 가능
- 다른 메서드나 함수에 매개변수로 전달 가능
- 이름을 명확히 구분하는 용도

```cpp
void SpreadsheetCell::setValue(double value){
  value = value; // 모호한 표현
}

// this 포인터 사용
void SpreadsheetCell::setValue(double value){
  this.value = value; // 명확히 구분
}
```

## 8.2.3 객체 사용법
- 객체를 생성해서 사용하는 방법에 대해서 알아보자. 크게 두가지가 있다.
  
  1. 스택에 생성하는 방법
  2. 힙에 생성하는 방법


### 1. 스택에 생성한 객체
```cpp
// 객체를 스택에 생성한 예제
SpreadsheetCell myCell, anotherCell;
myCell.setValue(6);
anotherCell.setString("3.2");
cout << "cell 1: " << myCell.getValue() << endl;
cout << "cell 2: " << anotherCell.getValue() << endl;
```
- 변수 타입이 클래스 이름이라는 것이 다름.
- 데이터 멤버를 public으로 선언하는 것은 바람직하지 않다.


### 2. 힙에 생성한 객체
```cpp
// new 를 사용하여 힙에 동적으로 생성한 예제
SpreadsheetCell* myCellp = new SpreadsheetCell();
myCellp->setValue(3.7);
cout << "cell 1: " << myCellp->getValue() << " " << myCellp->getString() << endl;
delete myCellp;
myCellp = nullptr;
```
- 힙에 생성하면 **->** 연산자를 통해 멤버에 접근
- 이는역참조 연산자(*)와 멤버 접근 연산자(.)를 합친 것
- 힙에 할당한 객체 메모리도 반드시 delete를 통해서 해제 필수
- 반드시 아래와 같이 스마트 포인터를 사용하자!

```cpp
auto myCellp = make_unique<SpreadsheetCell>();
myCellp->setValue(3.7);
cout << "cell 1: " << myCellp->getValue() << " " << myCellp->getString() << endl;
```
- 스마트 포인터를 사용하면 메모리를 자동으로 해제하므로 delete를 사용할 필요가 없음.

# 8.3 객체의 라이프 사이클
- 객체 라이프 사이클에 대해서 알아보자.
- **생성 소멸 대입**의 세 단계로 구성되어짐.
- 동작을 원하는 방식으로 변경하는 방법도 알아두자.

## 8.3.1 객체 생성
```cpp
#include <string>

class MyClass{
  private:
    std::string mName;
};

int main() {
  MyClass obj;
  return 0;
}
```
- 객체도 선언과 동시에 초기값을 설정하는 것을 권장
- 이 작업은 **생성자** 라고 부르는 특수한 메서드에서 객체를 초기화하는 코드를 작성하는 방식으로 처리할 수 있음.
- 생성자를 간단히 ctor라고 부름.


### 1. 생성자 작성 방법
```cpp
class SpreadsheetCell {
  public:
    SpreadsheetCell(double initialValue);
    // 나머지 부분 생략
};

// 구현 코드
SpreadsheetCell::SpreadsheetCell(double initialValue) {
  setValue(initialValue);
}
```
- 생성자도 일반 메서드를 구현하듯 구현코드를 작성해야 함.
- 생성자 이름은 클래스 이름과 똑같이 지정.
- 리턴값 없으며 필요에 따라서 매개변수를 받음.
- 특히 아무런 인수를 주지 않고 호출하는 생성자를 **디폴트 생성자** 라고 한다.
- 생성자도 일종의 SpreadsheetCell 클래스 멤버이다! 따라서 지정 연산자를 붙여야 함.


### 2. 생성자 사용법
- 객체는 생성자를 통해 생성이 됨.
- 또한 그 객체의 값을 초기화 할 수 있다.
- 스택과 힙 객체에 모두 생성자를 사용 가능

#### 스택 객체 생성자
```cpp
SpreadsheetCell myCell(5), anotherCell(4);
cout << "cell 1: " << myCell.getValue() << endl;
cout << "cell 2: " << anotherCell.getValue() << endl;
```
- 이 때, SpreadsheetCell 생성자를 아래와 같이 선언과 동시에 호출하면 안 된다.

```cpp
SpreadsheetCell myCell.SpreadsheetCell(5); // 컴파일 에러!

// 마찬가지로 선언한 뒤 호출도 불가!
SpreadsheetCell myCell;
myCell.SpreadsheetCell(5); // 컴파일 에러!
```

#### 힙 객체 생성자
```cpp
auto smartCellp = make_unique<SpreadsheetCell>(4);
// ... 셀을 다룸 스마트 포인터이므로 직접 삭제하지 않아도 무방

// 일반 포인터도 사용 가능 but 권장하지는 않음
SpreadsheetCell* myCellp = new SpreadsheetCell(5);
SpreadsheetCell* anotherCellp = nullptr;
anotherCellp = new SpreadsheetCell(4);
// ... 셀을 다룸

// clean
delete myCellp;
myCellp = nullptr;
delete anotherCellp;
anotherCellp = nullptr;
```


### 3. 생성자 여러개 제공하기
- 클래스에 여러 생성자를 만들 수도 있다.
- 인수의 개수나 타입만 서로 다르게 정의
- 이를 *오버로딩* 이라고 한다.

```cpp
// 두 개의 생성자를 갖도록 수정한 예제
class SpreadsheetCell {
  public:
    SpreadsheetCell(double initialValue);
    SpreadsheetCell(std::string_view iitialValue);
    // 생략..
};

// 두 번쨰 생성자의 구현 코드
SpreadsheetCell::SpreadsheetCell(string_view initialValue) {
  setString(initialValue);
}

// 정의한 생성자를 사용하는 예제
SpreadsheetCell aThirdCell("Test"); // string 타입의 인수를 받는 생성자 사용
SpreadsheetCell aFourthCell(4.4); // double 타입의 인수를 받는 생성자 사용
auto aFifthCellp = make_unique<SpreadsheetCell>("5.5"); // string 타입의 인수를 받는 생성자 사용

cout << "aThirdCell: " << aThirdCell.getValue() << endl;
cout << "aFourthCell: " << aFourthCell.getValue() << endl;
cout << "aFifthCellp: " << aFifthCellp->getValue() << endl;
```

- 생성자가 여러개라면 한 생성자 안에서 또 다른 생성자를 호출할 수도 있다. (복잡...하다..)
- string 타입을 인수로 받는 생성자에서 double 타입 인수를 받는 생성자를 호출하는 예제를 보자.
```cpp
SpreadsheetCell::SpreadsheetCell(string_view initialValue){
  SpreadsheetCell(stringToDouble(initialValue));
}
```

- 위의 예제는 *의도한 대로 실행되지 않는다!* 이는 **위임 생성자**를 이용하면 가능함.

### 4. 디폴트 생성자
- 아무런 인자를 받지 않는 생성자.
- 또 다른 말로 영인수(제로 인수) 생성자 라고 함.


> 디폴트 생성자가 필요한 경우
> - SpreadsheetCell 클래스에 디폴트 생성자를 정의하지 않으면 컴파일 에러 발생
> ```cpp
> SpreadsheetCell cells[3]; // 컴파일 오류!
> SpreadsheetCell* myCellp = new SpreadsheetCell[10]; // 여기서도 오류!
> ```
> - 객체 배열을 생성할 때는 클래스에 디폴트 생성자를 정의하는 것이 편함!
> - std::vector와 같은 라이브러리 컨테이너에 저장하려면 디폴트 생성자를 꼭 정의!


> 디폴트 생성자 작성법
> ```cpp
> class SpreadsheetCell {
>   public:
>     SpreadsheetCell();
>     // 생략
> };

> 컴파일러에서 생성한 디폴트 생성자

> 명시적 디폴트 생성자

> 명시적으로 삭제된 생성자

### 5. 생성자 이니셜라이저

### 6. 복제 생성자

> 복제 생성자가 호출되는 경우

> 복제 생성자 명시적 호출

> 레퍼런스로 객체 전달

> 명시적으로 디폴트로 만든 복제 생성자와 명시적으로 삭제된 복제 생성자

### 7. 이니셜라이저 리스트 생성자

### 8. 위임 생성자

### 9. 컴파일러가 생성하는 생성자에 대한 정리

## 8.3.2 객체 소멸

## 8.3.3 객체에 대입하기

### 1. 대입 연산자 선언 방법

### 2. 대입 연산자 정의 방법

### 3. 명시적으로 디폴트로 만들거나 삭제한 대입 연산자

## 8.3.4 컴파일러가 만들어주는 복제 생성자와 복제 대입 연산자

## 8.3.5 복제와 대입 구분하기

### 1. 리턴값이 객체인 경우

### 2. 복제 생성자와 객체 멤버

# 8.4 요약

- 객체와 클래스의 개념을 확실히 짚고 넘어갈 수 있도록 하자.
- 다음 장에서는 객체와 클래스에 관련된 보다 자세한 사항과 활용 기법에 대해서 알아보자.