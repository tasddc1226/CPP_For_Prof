# 1.1.6 타입
---

- C++ 에서는 기본 타입을 조합해서 더 복잡한 타입을 정의할 수 있다.
- C언어에서도 사용하던 것으로 소개.
- 다른 사람이 작성한 코드를 이해하기 위해서 알아두자.

## 1. 열거 타입 (enum)

- 숫자를 나열하는 방식과 범위를 마음대로 정의해서 변수를 선언하는데 활용

```clike

// const로 값이 변하지 않도록 정의
const int PieceTypeKing = 0
const int PieceTypeQueen = 1;
const int  PieceTypeRook = 2;
const int PieceTypePawn = 3;

// 기타
int myPiece = PieceTypeKing;

```

- enum type을 적용하면 변수에 지정할 수 있는 값의 범위를 엄격하게 제한

```clike

// 변수가 네 가지 값만 가질 수 있도록 제한
enum PieceType{
    PieceTypeKing,
    PieceTypeQueen,
    PieceTypeRook,
    PieceTypePawn
};

```

- enum을 구성하는 멤버는 내부적으로 정수값을 갖는다.
    - 위의 예시에서는 King부터 0 ..
    - 위의 변수에 대해 사칙연산을 수행하면 컴파일 경고 또는 에러 메시지 발생.

```clike

// error 발생
PieceType myPiece;
myPiece = 0;

```

- enum을 정의할 때 각 멤버에 정숫값 지정 가능

```clike

// PieceTypeQueen은 2, PieceTypePawn은 11의 값을 갖게 된다.
enum PieceType {
    PieceTypeKing = 1,
    PieceTypeQueen,
    PieceTypeRook = 10,
    PieceTypePawn
};

```


## 2. 엄격한 열거 타입

- 스트롱 타입 : 엄격하게 타입을 따지는 것. 타입에 안전하다고 표현함.

- 엄격하게 타입을 적용하고 싶다면? enum class 사용.

```clike

// type safe ver.
enum class PieceType{
    King = 1,
    Queen,
    Rook = 10,
    Pawn
};

```

- 스코프가 자동으로 확장되어지지 않으므로 해당 enum class 스코프 안에서만 유효.

```clike

// 스코프 지정 연산자를 붙여야 함.
PieceType piece = PieceType::King;

```

- enum class로 정의한 타입 값은 정수로 타입이 변환되어지지 않는다. 따라서 다음은 잘못된 표현

```clike

if (PieceType::Queen == 2) { ... }

// 올바른 표현
static_cast<int>(PieceType::Queen)

```

    열거 타입을 사용할 때는 type-unsafe한 enum 보다는 type-strong 버전인 enum class를 사용하는 것이 좋다.


## 3. 구조체

- 구조체를 사용하면 기존의 정의된 타입을 한 개 이상 묶어서 새로운 타입으로 정의가 가능하다.

- 구체적인 예로 DB Records가 있다.

```clike

// 직원 정보 관리 시스템 구축하기 위한 직원의 정보
// employeestruct.h

struct Employee {
    char firstInitial;
    char lastInitial;
    int employeeNumber;
    int salary;
};
```

```clike

// 직원에 대한 레코드를 생성한 뒤, 그 결과를 콘솔에 출력.
#include <iostream>
#include "employeestruct.h"

using namespace std;

int main() {
    // 직원 레코드 생성 및 값 채우기
    Employee anEmployee;
    anEmployee.firstInitial = 'M';
    anEmployee.lastInitial = 'G';
    anEmployee.employeeNumber = 42;
    anEmployee.salary = 80000;

    // 저장된 값 출력
    cout << "Employee: " << anEmployee.firstInitial << anEmployee.lastInitial << endl;
    cout << "Number: " << anEmployee.employeeNumber << endl;
    cout << "Salary: $" << anEmployee.salary << endl;
    return 0;
}

```